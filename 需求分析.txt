   ##利用Tcp协议，自定义一个协议，模拟QQ服务器和客户端信息传输

   1）需求分析
       1.实现聊天服务器；
       2.实现聊天客户端；
     功能：
       1. 登录；
       2. 退出；
       3. 发送消息；
       4. 获取离线消息；
       5. 获取在线用户；


   2)QQ服务器（myQQ_Server）要实现的功能：
        1.转发消息
        2.处理登录
        3.处理退出
        4.维护历史消息， 维护在线用户和维护用户的连接

   3)消息的格式都是json格式则调用的时候也要用json来调用
    # 将获取到的消息转为dict进行传输，然后再利用dump进行数据的调用

        # 多线程去处理每个用户连接，防止主线程阻塞住
        # 自定义消息协议并且完成消息协议的解析

        根据序列化和反序列的特性
        loads： 是将string转换为dict
        dumps： 是将dict转换为string
        load： 是将里json格式字符串转化为dict，读取文件
        dump： 是将dict类型转换为json格式字符串，存入文件

   4)客户端的定义和实现
     1.先登录后传输数据

   5)历史消息的获取  发消息的思路
        1.发消息是不断的在发消息的过程（随时都可以发送消息）； 所以要进行监控随时都要接收发消息 While 循环来进行这个功能

        2.有新对的消息随时可以接收到；

        3.用户发送消息的时候也有接收数据，但是不能直接在循环里面进行，因为接收信息的时候是利用一个阻塞的方式，如果没有一个消息的时候
        就会一直阻塞在那边不运行，那么就会卡循环，不能进入后面的判断，这时候就要用多线程的方式来接收信息；
            ##怎么使用多线程的方法呢？
                1.利用一种方法来包裹这个循环函数，从而来定义多线程
                2.利用多线程来编写

            ##定义一个方法来处理接收请求
                1.处理消息的时候也要进行不断的接收 while True;
                ### json_data中的数据是通过 json_loads（）来获取数据，里面的数据是通过获取传送回来的数据
                2.进行一个json_data 包的获取
                3.拿到消息；通过json_data里面获取
                4.拿到来自的用户； 通过json_data里面获取
               ################
                   #### 处理接受请求
                    def handle_receive():
                        while True:
                            res = client.recv(1024)
                            res = res.decode("utf8")
                            res_json = json.loads(res)
                            msg = res_json["data"]
                            from_user = res_json["from"]
                            print("收到来自({})的消息： {}".format(from_user,msg))
               ################
                    ##处理接收到的数据类型也可能不是json类型，所以需要一个来捕获错误了；
                    ##如果在发送消息的时候已经退出了 则接收消息的时候也要进行退出，这时候则需要利用一个全局来判断 如果没有进入exit则直接退出break;

               ####recv接收的时候会有阻塞现象，则接收的时候也要定义避免阻塞；
                    则会报异常，那么利用try except来进行操作；进行直接退出的操作


               总结：
                    1.这是一项初级的利用多线程进行一个交互的聊天功能，基于Tcp协议而开发的交互方式的自定义的另一种协议
                    2.首先是服务器的开发，服务器进行一项交互，封装转发的功能
                    3.JSON中接收的是str类型的输数据，而Python中传输的是dict类型的数据，所以json使用的时候要用dumps进行转换
                    4.接收数据的时候 都是经过数据的阻塞来进行用户数据的交互
                    5.协议也是基于Socket来使用，进行交互
                    6.tmp_data = sock.recv(1024)  是为了拿到数据的最大值
                    7.JSON中的Loads是将客户端传来的str包装成dict进行传输
                    8.利用Python中get的方式来获取客户端传来状态值，进行分析
                    9.客户端传给服务端的时候则利用客户端JSON中dumps   将dict转为str传给服务器
                    10.客户端要做的是 1.将拿到的信息传给服务端，服务端进行解析封装在回给客户端；
                    11.最后也就是经过这种方式就可以进行交互了
		    12.当然了解更多交互协议可以去看看XMPP的使用

